{"version":3,"sources":["jquery.observable.js"],"names":["factory","global","eval","$","jQuery","define","amd","exports","module","setGlobals","fn","$observe","$observable","versionNumber","$views","views","jsrender","jsviews","sub","$sub","$isFunction","isFunction","$isArray","isArray","OBJECT","observe","$eventSpecial","event","special","slice","splice","concat","$expando","expando","PARSEINT","parseInt","rNotWhite","propertyChangeStr","propChng","arrayChangeStr","arrChng","cbBindingsStore","_cbBnds","observeStr","observeObjKey","observeCbKey","observeInnerCbKey","$hasData","hasData","$data","data","remove","getCbKey","cb","_cId","ObjectObservable","this","_data","ArrayObservable","wrapArray","resolvePathObjects","paths","root","i","path","object","nextObj","l","length","out","call","push","removeCbBindings","cbBindings","cbBindingsId","undefined","onObservableChange","ev","eventArgs","isOb","val","allowArray","off","allPath","filter","parentObs","oldValue","value","ctx","observeAll","noArray","type","array","prop","_path","target","parents","observe_apply","ns","args","apply","arguments","shift","$observeAll","namespace","unobserve","$unobserveAll","objMap","observeArrayItems","arr","unobs","newAllPath","filterAndObserveAll","obj","nestedArray","newObject","newParentObs","_fltr","nextParentObs","updatedTgt","unshift","wrappedCb","change","items","oldItems","isObject","obId","notRemoving","un","window","map","shallowFilter","indexOf","$unobserve","innerObserve","observeOnOff","pathStr","isArrayBinding","j","evData","obIdExpando","boundObOrArr","prntObs","allPth","initialNs","events","el","callback","fullPath","replace","all","inArray","on","getInnerCb","exprOb","origRt","ob","contextCb","sb","newObj","bindArray","unbind","relPath","prevObj","prevAllPath","cbId","p","skip","parts","dep","depth","innerCb","initNsArr","initNsArrLen","lastArg","pop","_inId","match","split","join","_jsv","bnd","prm","origRoot","nodeType","depends","getDeps","arg","deps","observable","set","Object","Array","_apply","prototype","unobserveAll","setProperty","nonStrict","key","pair","self","name","_setProperty","removeProperty","leaf","setter","getter","removeProp","property","Date","_trigger","triggerHandler","insert","index","_insert","oldLength","numToRemove","_remove","move","oldIndex","newIndex","numToMove","_move","refresh","newItems","_refresh","$_data","handleObj","found","mapDef","Map","source","options","unbound","changing","src","unmap","tgt","update","obsSrc","obs","srcFlt","obsTgt","obt","tgtFlt","getTgt","baseMap","extend","_def","constructor"],"mappings":";CAWC,SAASA,GAET,GAAIC,IAAU,EAAGC,MAAM,QACtBC,EAAIF,EAAOG,MAEU,mBAAXC,SAAyBA,OAAOC,IAC1CD,QAAQ,UAAWL,GACU,gBAAZO,SACjBC,OAAOD,QAAUJ,EACdH,EAAQG,GACR,SAASA,GACV,MAAOH,GAAQG,IAGjBH,GAAQ,IAKV,SAASG,GACT,YAKA,IAAIF,IAAU,EAAGC,MAAM,QACtBO,EAAaN,KAAM,CAIpB,IAFAA,EAAIA,GAAKF,EAAOG,QAEXD,IAAMA,EAAEO,GAEZ,KAAM,8BAGP,IACCC,GAAUC,EADPC,EAAgB,eAGnBC,EAASX,EAAEY,MACVZ,EAAEY,OACFN,GAAcR,EAAOe,UAAYA,SAASD,QAEzCE,QAASJ,EACTK,QAEFC,EAAOL,EAAOI,IACdE,EAAcjB,EAAEkB,WAChBC,EAAWnB,EAAEoB,QACbC,EAAS,QACV,KAAKrB,EAAEsB,QAAS,CAEf,GAAIC,GAAgBvB,EAAEwB,MAAMC,QAC3BC,KAAWA,MACXC,KAAYA,OACZC,KAAYA,OACZC,EAAW7B,EAAE8B,QACbC,EAAWC,SACXC,EAAY,OACZC,EAAoBlB,EAAKmB,SAAWnB,EAAKmB,UAAY,iBACrDC,EAAiBpB,EAAKqB,QAAUrB,EAAKqB,SAAW,cAChDC,EAAkBtB,EAAKuB,QAAUvB,EAAKuB,YACtCC,EAAaN,EAAoB,WACjCO,EAAgB,EAChBC,EAAe,EACfC,EAAoB,EACpBC,EAAW5C,EAAE6C,QACbC,EAAQ9C,EAAE+C,KACVC,KAIDC,EAAW,SAASC,GACnB,MAAOA,GAAGC,KAAOD,EAAGC,MAAS,OAAST,KAGvCU,EAAmB,SAASL,GAE3B,MADAM,MAAKC,MAAQP,EACNM,MAGRE,EAAkB,SAASR,GAE1B,MADAM,MAAKC,MAAQP,EACNM,MAGRG,EAAY,SAAST,GACpB,MAAO5B,GAAS4B,IACZA,GACDA,GAGJU,EAAqB,SAASC,EAAOC,GACpCD,EAAQvC,EAASuC,GAASA,GAASA,EAEnC,IAAIE,GAAGC,EACNC,EAASH,EACTI,EAAUD,EACVE,EAAIN,EAAMO,OACVC,IAED,KAAKN,EAAI,EAAOI,EAAJJ,EAAOA,IAClBC,EAAOH,EAAME,GACT3C,EAAY4C,GACfK,EAAMA,EAAItC,OAAO6B,EAAmBI,EAAKM,KAAKR,EAAMA,GAAOA,IAEjD,GAAKE,IAASA,GAOrBE,IAAYD,GACfI,EAAIE,KAAKN,EAASC,GAEnBG,EAAIE,KAAKP,KATRF,EAAOI,EAAUF,EACbE,IAAYD,GACfI,EAAIE,KAAKN,EAASC,GASrB,OAAOG,IAGRG,EAAmB,SAASC,EAAYC,GAEvC,IAAK,GAAIrB,KAAMoB,GACd,MAEDhC,GAAgBiC,GAAgBC,QAGjCC,EAAqB,SAASC,EAAIC,GACjC,QAASC,GAAKC,GACb,aAAcA,KAAQxD,IAAWqC,EAAM,IAAMoB,GAAc3D,EAAS0D,IAGrE,IAAMH,EAAG3B,OAAQ2B,EAAG3B,KAAKgC,IAAM,CAE9B,GAAIC,GAASC,EAAQC,EACpBC,EAAWR,EAAUQ,SACrBC,EAAQT,EAAUS,MAClBC,EAAMX,EAAG3B,KACTuC,EAAaD,EAAIC,WACjBR,GAAcO,EAAInC,GAAGqC,QACrB7B,EAAQ2B,EAAI3B,KAETgB,GAAGc,OAASpD,GACdiD,EAAInC,GAAGuC,OAASJ,EAAInC,IAAIiB,KAAKkB,EAAKX,EAAIC,IAE7BU,EAAIK,OAASf,EAAUd,MAAqB,MAAbwB,EAAIK,QACzCJ,GACHN,EAAUM,EAAWK,MAAQ,IAAMhB,EAAUd,KAC7CoB,EAASK,EAAWL,OACpBC,GAAaR,EAAGkB,QAAQhE,OAAO0D,EAAWO,WAEtCjB,EAAKO,IACRW,EAAchB,EAAYQ,EAAWS,IAAKZ,GAAWzB,EAAO2B,EAAInC,IAAI,EAAM+B,GAASC,GAAYF,GAE5FJ,EAAKQ,IACRU,EAAchB,EAAYQ,EAAWS,IAAKX,GAAQ1B,EAAO2B,EAAInC,GAAIsB,OAAWS,GAASC,GAAYF,KAG9FJ,EAAKO,IACRW,EAAchB,GAAaK,GAAWzB,EAAO2B,EAAInC,IAAI,GAElD0B,EAAKQ,IACRU,EAAchB,GAAaM,GAAQ1B,EAAO2B,EAAInC,KAGhDmC,EAAInC,GAAGwB,EAAIC,MAKdmB,EAAgB,WAEf,GAAIE,GAAOpE,EAAOqE,SAAUC,UAC5B,OAAO1F,GAASyF,MAAMD,EAAKG,QAASH,IAGrCI,EAAc,SAASC,EAAWnD,EAAI+B,EAAQqB,GACzCD,EAAY,KAAOA,IACtBpB,EAAS/B,EACTA,EAAKmD,EACLA,EAAY,IAEbf,EAAWe,EAAWhD,KAAKC,MAAOJ,EAAI+B,KAAY,OAAQqB,IAG3DC,EAAgB,SAASF,EAAWnD,EAAI+B,GACvCmB,EAAYjC,KAAKd,KAAMgD,EAAWnD,EAAI+B,GAAQ,IAG/CK,EAAa,SAASe,EAAWvC,EAAQZ,EAAI+B,EAAQC,EAAWF,EAASsB,EAAWE,GACnF,QAASC,GAAkBC,EAAKC,GAG/B,IAFA3C,EAAI0C,EAAIzC,OACR2C,EAAa5B,EAAU,KAChBhB,KACN6C,EAAoBH,EAAK1C,EAAG2C,EAAO,GAIrC,QAASE,GAAoBC,EAAKpB,EAAMiB,EAAOI,GAC9C,GAAIC,GAAWC,CACXvB,KAAS7D,IACRmF,EAAYvG,EAAYyG,MAAMN,EAAYE,EAAIpB,GAAOyB,EAAelC,MACvEgC,EAAeE,EAAczF,QACzBqF,GAAeK,GAClBH,EAAaI,QAAQD,GAEtB9B,EAAWe,EAAWW,EAAW9D,EAAI+B,IAAW8B,EAAcvC,OAAY,GAAIyC,EAAcL,EAAYD,EAAOH,IAMlH,QAASc,GAAU5C,EAAIC,GAItB,OAFAK,EAAUN,EAAG3B,KAAKuC,WAAWK,MAC7ByB,EAAa1C,EAAGkB,OACRjB,EAAU4C,QACjB,IAAK,SACJd,EAAkB9B,EAAU6C,MAC5B,MACD,KAAK,SACJf,EAAkB9B,EAAU6C,OAAO,EACnC,MACD,KAAK,UACJf,EAAkB9B,EAAU8C,UAAU,GACtChB,EAAkB/B,EAAGkB,OACrB,MACD,KAAK,MACJgB,EAAa5B,EAAU,IAAML,EAAUd,KACvCgD,EAAoBlC,EAAW,YAAY,GAC3CkC,EAAoBlC,EAAW,SAEjCyC,EAAa5C,OACbtB,EAAG+C,MAAM5C,KAAM6C,WAGhB,GAAIlC,GAAG0D,EAAUd,EAAYO,EAAeC,EAAYO,EACvDC,GAAepB,GAAUA,EAAOqB,KAAOvB,CAExC,IAAIxC,SAAiBA,KAAWzC,EAAQ,CAGvC,GAFA8F,GAAiBrD,GAAQlC,OAAOsD,GAChCwC,EAAWvG,EAAS2C,GAAU,GAAK,IAC/B0C,GAAUoB,GAAehF,EAASkB,IAAW0C,EAAOmB,EAAO7E,EAAMgB,GAAQ6D,MAE5E,WADAnB,GAAOmB,IASR,IAJKnB,IACJsB,OAAOC,IAAMvB,GAAUqB,GAAIvB,IAGxBpD,GAEH,GAAIwE,GAAuB,IAAXzC,EAOf,GAFAqC,EAAUnE,KAAOF,EAASC,GAEtB0E,EACHpH,EAAS6F,EAAWvC,EAAQ4D,EAAUJ,EAAWhB,EAAWrB,EAAQkC,EAAenC,GACnF2C,EAAO7E,EAAMgB,GAAQ6D,KACrBnB,EAAOmB,IAASnB,EAAOmB,IAAS,GAAK,MAE/B,CACN,KAAMnB,EAAO1D,EAAMgB,GAAQ6D,MAG1B,MAEDnH,GAAS6F,EAAWvC,EAAQ4D,EAAUJ,EAAWhB,EAAWrB,EAAQkC,EAAenC,QAKjFwB,KACHA,EAAO1D,EAAMgB,GAAQ6D,MAAQ,GAE9BnH,EAAS6F,EAAWvC,EAAQ4D,EAAUlD,OAAW8B,EAAWrB,EAAQkC,EAAenC,EAGpF,IAAI0C,EAGH,IAAK1D,IAAKF,GACT8C,EAAa5B,EAAU,IAAMhB,EAC7B6C,EAAoB/C,EAAQE,EAAGsC,OAGhCG,GAAkB3C,EAAQwC,KAK7B0B,EAAgB,SAAShD,GACxB,MAAOA,GAAQiD,QAAQ,KAAO,GAAKjD,EAAQiD,QAAQ,KAAO,GAG3DC,EAAa,WAEZ,SADG9D,KAAKD,KAAK+B,WAAW,GACjB1F,EAASyF,MAAM5C,KAAM6C,WAG7B1F,GAAW,WAGV,QAAS2H,KAER,QAASC,GAAa/B,EAAWgC,EAASC,EAAgBvD,GACzD,GAAIwD,GAAGC,EACNC,EAAc7F,EAASkB,IACvB4E,EAAelF,EAAUM,IACzB6E,EAAUzD,EACV0D,EAAS5D,CAIV,IAFAqB,EAAYwC,EAAYxC,EAAY,IAAMwC,EAAYxC,EAElDC,GAAavB,EACZ0D,GACHzI,EAAE0I,GAAc3D,IAAIsB,EAAW5B,OAE1B,CACN,GAAIqE,EAASL,GAAezI,EAAEsD,MAAMQ,IAKnC,IAJAgF,EAASA,GAAUA,EAAOA,OAC1BA,EAASA,GAAUA,EAAOR,EAAiBlG,EAAiBF,GAC5D6G,EAAKD,GAAUA,EAAO7E,OAEf8E,KACN,IAAKhG,EAAO+F,EAAOC,GAAIhG,OAASA,EAAKG,IAAMH,EAAKG,GAAGC,OAAS6F,EAAS7F,MAAQJ,EAAKgD,KAAO8C,EAAW,CACnG,GAAIP,EAGH,MACsB,OAAZD,GAAmBtF,EAAK2C,OAAS2C,GAC3CrI,EAAE8D,IAAQiB,IAAIsB,EAAW5B,GAK7B+D,EAASF,MAEPW,SAAUpF,EACVH,MAAO2E,GAAWA,MAClB3C,KAAMA,GAER8C,EAAOzC,GAAK8C,EACZL,EAAOtF,GAAK8F,EAERhE,IAEHwD,EAAOlD,YACNK,MAAOiD,EACP/E,KAAM,WAEL,MADA0E,GAAII,EAAQ1E,OACL2E,EAAOM,QAAQ,QAAS,SAASC,GAEvC,MADAZ,KACe,MAARY,EACJ,IAAMnJ,EAAEoJ,QAAQT,EAAQJ,EAAI,GAAII,EAAQJ,IACxC,OAGL1C,QAAS,WACR,MAAO8C,IAER1D,OAAQA,EACRc,GAAI8C,IAGN7I,EAAE0I,GAAcW,GAAGhD,EAAW,KAAMmC,EAAQ/D,GACxCH,KAEFhC,EAAgB0G,EAAS7F,MAAQmB,GAEhCxB,EAAMgB,IAAQ6D,MAAQ7E,EAAMgB,GAAQ,OAAQrB,MAAoBqB,KAKrE,QAASwF,GAAWC,GAMnB,GAAIC,GAAS7F,EAKb,OAFA4F,GAAOE,GAAKC,EAAUH,EAAQC,GAEvBD,EAAOrG,GAAK,SAASwB,EAAIC,GAC/B,GAAImC,GAAMyC,EAAOE,GAChB1I,EAAMwI,EAAOI,GACbC,EAASF,EAAUH,EAAQC,EAExBI,KAAW9C,UACHA,KAAQzF,IAClBwI,EAAU/C,GAAK,IACX/F,GAAO+D,GAAc3D,EAAS2F,KACjCqB,GAAcrB,GAAM/F,EAAKiI,EAAUU,GAAW,IAGhDH,EAAOE,GAAKG,QAEDA,KAAWvI,IACrBwI,EAAUD,IACN7I,GAAO+D,GAAc3D,EAASyI,KAEjCzB,GAAcyB,GAAS7I,EAAKiI,EAAUU,KAKzCV,EAAStE,EAAIC,IAIf,QAASkF,GAAUnD,EAAKoD,EAAQ1I,EAAS2I,GACxC,GAAIjF,EAAY,CAEf,GAAIkF,GAAUlG,GACbmG,EAAcjF,CAEflB,IAAS4C,EACLqD,IACHjG,GAAS4C,EAAIqD,GACb/E,GAAW,IAAM+E,GAEd9E,GAAUnB,KACbA,GAASrD,EAAYyG,MAAMlC,EAASlB,GAAQiG,GAAWrD,GAAK9E,OAAOsD,GAAaA,EAAWD,IAExFnB,KAAW1C,GAAWD,EAAS2C,MAClCsE,EAAahG,EAAiB,YAAc4G,EAAYkB,EAAOjH,EAAS+F,GAAa,IAAKxE,QAAW,EAAMsF,GAE5GhG,GAASkG,EACThF,EAAUiF,GAIZ,GAAIrG,GAAGuG,EAAGC,EAAMC,EAAO3E,EAAM7B,EAAMyG,EAAKhE,EAAW0C,EAAUkB,EAAMnB,EAAIhG,EAAM+F,EAAQY,EAAWlC,EAAOlD,EAAYiG,EAAOC,EAAStF,EAClIF,EAASC,EAAQwF,EAAWC,EAC5B3E,EAAKvD,EACLkB,GAAgB,GAARL,KACLzB,EAAOqE,SAAUC,WAEjBxE,EAAMyC,KAAK+B,WACdyE,GAAUjH,GAAMkH,QAAS,EACzBjH,GAAOD,GAAMyC,QACbrC,GAASH,GACTK,GAAIN,GAAMO,MAgCX,KA9BI0G,GAAU,KAAOA,KACpB3F,EAAU2F,GACVzF,EAAYxB,GAAMkH,MAClB3F,EAASvB,GAAMkH,MACfD,KAAYjH,GAAMkH,MAClB5G,IAAK,GAEF2G,OAAcA,KACjBrE,EAAYqE,GACZA,GAAUjH,GAAMM,GAAE,GAClB2G,GAAU3G,IAAK2G,GAAU,KAAOA,IAAW3G,KAAKN,GAAMkH,OAASpG,QAEhEwE,EAAW2B,GACP3G,IAAK/C,EAAYyC,GAAMM,GAAI,MAC9B0F,EAAYV,EACZA,EAAWtF,GAAMkH,MACjB5G,MAID+B,GAAMO,EACF0C,EAAWA,EAAS7F,MAAQ6F,EAAS6B,OAAS,IAAK,IACnDX,EAAOjH,EAAS+F,KAAcA,EAAS6B,OAAS,IAC/CvE,IACJhC,EAAahC,EAAgB4H,GAAQ5H,EAAgB4H,QAGtDO,EAAY5B,GAAaA,EAAUiC,MAAM7I,KAAe,IACxDyI,EAAeD,EAAUxG,OAElByG,KAYN,IAXA7B,EAAY4B,EAAUC,GAElBvJ,EAASwC,IACZkG,EAAUlG,GAAM2C,GAAW,GAGvBA,GAAmB,IAANtC,IAAWL,IAC3ByE,EAAarC,EAAI,IAGnBwE,EAAQ,EACH3G,EAAI,EAAOI,GAAJJ,EAAOA,IAElB,GADAC,EAAOH,GAAME,GACA,KAATC,GAAwBW,SAATX,EAAnB,CAIA,GADAC,GAASH,GACL,GAAKE,IAASA,EAAM,CAiBvB,GATAwG,EAAQxG,EAAKkH,MAAM,KACfV,EAAM,KAGTE,EAAQF,EAAM,GAAGU,MAAM,KAAK9G,OAC5BJ,EAAOwG,EAAMW,KAAK,KAClBT,EAAQ1G,EAAKkH,MAAM,KAAK9G,OAASsG,GAG9Bb,IAAclC,EAAQkC,EAAU7F,EAAMF,KAAQ,CAGjDK,IAAKwD,EAAMvD,OAAS,EACpBtC,EAAOsE,MAAMvC,IAAQE,IAAK,GAAGhC,OAAO4F,GACpC,UAED6C,EAAQxG,EAAKkH,MAAM,SAEd9J,GAAY4C,KACZA,GAAQA,EAAKoH,MAGhBT,EAAUlE,EAAYzC,EAAKX,GAAKoG,EAAWzF,GAC3C2G,EAAQjF,SAAWT,EACnB0F,EAAQrH,KAAO6F,EAAS7F,KAExBqH,EAAQK,MAAQL,EAAQK,OAAS,QAAUlI,KACvCkB,EAAKqH,KAAOrH,EAAKsH,KAAOtH,EAAKsH,IAAIlH,SAAWJ,EAAK8F,KAGpDxB,GAAcrE,IAASD,EAAKA,MAAOuH,GAAWvH,EAAKsH,IAAKX,EAASd,EAAWpD,GAEzEzC,EAAK8F,IACRxB,GAActE,EAAK4F,IAAK5F,EAAK8F,GAAIX,EAAUU,EAAWpD,GAEvDzC,EAAOuH,EACPtH,GAASU,QAETV,GAASD,GAGXwG,GAAS1G,GAAOE,EAEjB,MAAOC,IAAqCU,UAA1BkB,EAAO2E,EAAMlE,UAC9B,SAAWrC,MAAWzC,EAAQ,CAC7B,GAAI,GAAKqE,IAASA,EAAM,CACvB,GAAa,KAATA,EACH,QAED,IAAK2E,EAAMpG,OAASsG,EAAQ,IAAOzG,GAAOuH,SAAU,CAEnD,IAAK/E,IAAcwC,EAASlG,EAASkB,KAAW9D,EAAEsD,MAAMQ,KAAU,CAKjE,IAJAgF,EAASA,EAAOA,OAChBA,EAASA,GAAUA,EAAO5G,GAC1B6G,EAAKD,GAAUA,EAAO7E,OACtBmG,EAAO,EACArB,KACNhG,EAAO+F,EAAOC,GAAIhG,KACdA,GAAQA,EAAKG,KAAO8F,GAAYjG,EAAKgD,KAAO8C,IAC3C9F,EAAK2C,OAASA,GAAsB,MAAd3C,EAAK2C,SAC1ByE,EAAIE,EAAMW,KAAK,OAClBjI,EAAKW,MAAMU,KAAK+F,GAGjBC,IAIH,IAAIA,EAAM,CAETtG,GAASA,GAAO4B,EAChB,WAGF,GAAa,MAATA,EAAc,EACZY,GAAawC,GAAUA,EAAO7E,QAElCmE,EAAarC,EAAI,IAAI,GAAO,GAE7BqC,EAAarC,EAAI,GACjB,KAAKoE,IAAKrG,IAELqG,IAAMtI,GACTgI,EAAU/F,GAAQwC,EAAW9B,OAAW2F,EAG1C,OACUzE,GACV0C,EAAarC,EAAK,IAAML,EAAM2E,EAAMW,KAAK,MAGvChG,IACHA,GAAW,IAAMU,GAElBA,EAAO5B,GAAO4B,GAEf,GAAIzE,EAAYyE,GAAO,EAClB4E,EAAM5E,EAAK4F,UAEdnD,GAAcrE,IAASL,EAAmB6G,EAAKxG,IAASkF,EAAUU,EAAWpD,EAE9E,OAEDxC,GAAS4B,EAGXmE,EAAU/F,GAAQwC,GAQpB,MALI4D,IACH7F,EAAiBC,EAAY4F,IAIrBA,KAAMA,EAAMgB,IAAK5G,GAG3B,GAAIuE,GACH/D,EAAqB,GAARzB,KAGbK,EAAQhC,EAAMyC,KAAK+B,WACnBkF,EAAW1H,EAAM,EAQlB,OANI0H,GAAW,KAAOA,GAAYtG,IACjC+D,EAAYuC,EACZ1H,EAAMyC,QACNiF,EAAW1H,EAAM,IAGXyE,EAAalC,MAAM,EAAGvC,IAG9BjD,EAAc,SAASsC,GACtB,MAAO5B,GAAS4B,GACb,GAAIQ,GAAgBR,GACpB,GAAIK,GAAiBL,IAKzB/B,EAAKuK,QAAU,WACd,GAAIvF,GAAOE,SACX,OAAO,YAIN,IAHA,GAAIsF,GAAKlB,EACRmB,KACAzH,EAAIgC,EAAK/B,OACHD,KACNwH,EAAMxF,EAAKhC,KACXsG,EAAMtE,EAAKhC,GACPsG,IACHmB,EAAOA,EAAK7J,OAAOX,EAAYqJ,GAAOA,EAAIkB,EAAKA,GAAOlB,GAGxD,OAAOmB,KAITzL,EAAE0L,WAAajL,EACfA,EAAYyG,MAAQ,SAASlC,EAASlB,EAAQoB,EAAWD,GACxD,OAAIA,GAAUhE,EAAYgE,GACvBA,EAAOD,EAASlB,EAAQoB,IACxB,IAEFpB,EAAS7C,EAAY6C,GAClBA,EAAO6H,KAAO7H,EAAOK,KAAKe,EAAU,IACpCpB,QACWA,KAAWzC,GAAUyC,GAPpC,QAWDrD,EAAYmL,OAASxI,EACrB3C,EAAYoL,MAAQtI,EACpBvD,EAAEsB,QAAUb,EAAYa,QAAUd,EAClCR,EAAEsG,UAAY7F,EAAY6F,UAAY4B,EACtCzH,EAAYqL,OAAShG,EAErB1C,EAAiB2I,WAChBzI,MAAO,KAEPgC,WAAYc,EACZ4F,aAAczF,EAEdxD,KAAM,WACL,MAAOM,MAAKC,OAGb2I,YAAa,SAASpI,EAAMuB,EAAO8G,GAClC,GAAIC,GAAKC,EAAM/B,EACdgC,EAAOhJ,KACPS,EAASuI,EAAK/I,KAGf,IADAO,EAAOA,GAAQ,GACXC,EACH,GAAI3C,EAAS0C,GAIZ,IADAsI,EAAMtI,EAAKI,OACJkI,KACNC,EAAOvI,EAAKsI,GACZE,EAAKJ,YAAYG,EAAKE,KAAMF,EAAKhH,MAAqBZ,SAAd0H,GAA2BA,OAE9D,IAAI,GAAKrI,IAASA,EAExB,IAAKsI,IAAOtI,GACXwI,EAAKJ,YAAYE,EAAKtI,EAAKsI,GAAMD,OAE5B,IAAIrI,IAAShC,EAAU,CAG7B,IADAwI,EAAQxG,EAAKkH,MAAM,KACZjH,GAAUuG,EAAMpG,OAAS,GAC/BH,EAASA,EAAOuG,EAAMlE,QAEnBrC,IACHuI,EAAKE,aAAazI,EAAQuG,EAAM,GAAIjF,EAAO8G,GAI9C,MAAOG,IAGRG,eAAgB,SAAS3I,GAExB,MADAR,MAAK4I,YAAYpI,EAAMb,GAChBK,MAGRkJ,aAAc,SAASE,EAAM5I,EAAMuB,EAAO8G,GACzC,GAAIQ,GAAQC,EAAQC,EACnBC,EAAWhJ,EAAO4I,EAAK5I,GAAQ4I,CAE5BxL,GAAY4L,IACXA,EAASlB,MAEZgB,EAASE,EACTH,EAASG,EAASlB,OAAQ,EAAOkB,EAAWA,EAASlB,IACrDkB,EAAWA,EAAS1I,KAAKsI,KAIvBI,IAAazH,GAAS8G,GAAaW,GAAYzH,OAE5CyH,YAAoBC,QAASD,EAAWzH,GAAoBA,EAAXyH,KAClDH,GACHA,EAAOvI,KAAKsI,EAAMrH,GAClBA,EAAQuH,EAAOxI,KAAKsI,KACVG,EAAaxH,IAAUpC,UAC1ByJ,GAAK5I,GACZuB,EAAQZ,QACEX,IACV4I,EAAK5I,GAAQuB,GAEd/B,KAAK0J,SAASN,GAAOlF,OAAQ,MAAO1D,KAAMA,EAAMuB,MAAOA,EAAOD,SAAU0H,EAAU7J,OAAQ4J,MAK7FG,SAAU,SAASnH,EAAQjB,GAC1B3E,EAAE4F,GAAQoH,eAAe9K,EAAmByC,KAI9CpB,EAAgBwI,WACfzI,MAAO,KAEPgC,WAAYc,EACZ4F,aAAczF,EAEdxD,KAAM,WACL,MAAOM,MAAKC,OAGb2J,OAAQ,SAASC,EAAOnK,GACvB,GAAIO,GAAQD,KAAKC,KAejB,OAdyB,KAArB4C,UAAUjC,SACblB,EAAOmK,EACPA,EAAQ5J,EAAMW,QAEfiJ,EAAQnL,EAASmL,GACbA,EAAQ,IAAMA,GAAS5J,EAAMW,SAChClB,EAAO5B,EAAS4B,GAAQA,GAAQA,GAI5BA,EAAKkB,QACRZ,KAAK8J,QAAQD,EAAOnK,IAGfM,MAGR8J,QAAS,SAASD,EAAOnK,GACxB,GAAIO,GAAQD,KAAKC,MAChB8J,EAAY9J,EAAMW,MACnBtC,GAAOsE,MAAM3C,GAAQ4J,EAAO,GAAGtL,OAAOmB,IACtCM,KAAK0J,UAAUxF,OAAQ,SAAU2F,MAAOA,EAAO1F,MAAOzE,GAAOqK,IAG9DpK,OAAQ,SAASkK,EAAOG,GACvB,GAAI7F,GACHlE,EAAQD,KAAKC,KAed,OAbckB,UAAV0I,IACHA,EAAQ5J,EAAMW,OAAS,GAGxBiJ,EAAQnL,EAASmL,GACjBG,EAAcA,EAActL,EAASsL,GAA+B,IAAhBA,EAAoB,EAAI,EACxEA,EAAc,IAAMH,EAAQ,KAC/B1F,EAAQlE,EAAM5B,MAAMwL,EAAOA,EAAQG,GACnCA,EAAc7F,EAAMvD,OAChBoJ,GACHhK,KAAKiK,QAAQJ,EAAOG,EAAa7F,IAG5BnE,MAGRiK,QAAS,SAASJ,EAAOG,EAAa7F,GACrC,GAAIlE,GAAQD,KAAKC,MAChB8J,EAAY9J,EAAMW,MAEnBX,GAAM3B,OAAOuL,EAAOG,GACpBhK,KAAK0J,UAAUxF,OAAQ,SAAU2F,MAAOA,EAAO1F,MAAOA,GAAQ4F,IAG/DG,KAAM,SAASC,EAAUC,EAAUC,GAKlC,GAJAA,EAAYA,EAAY3L,EAAS2L,GAA2B,IAAdA,EAAkB,EAAI,EACpEF,EAAWzL,EAASyL,GACpBC,EAAW1L,EAAS0L,GAEhBC,EAAY,GAAKF,EAAW,IAAMC,EAAW,IAAMD,IAAaC,EAAU,CAC7E,GAAIjG,GAAQnE,KAAKC,MAAM5B,MAAM8L,EAAUA,EAAWE,EAClDA,GAAYlG,EAAMvD,OACdyJ,GACHrK,KAAKsK,MAAMH,EAAUC,EAAUC,EAAWlG,GAG5C,MAAOnE,OAGRsK,MAAO,SAASH,EAAUC,EAAUC,EAAWlG,GAC9C,GAAIlE,GAAQD,KAAKC,MAChB8J,EAAY9J,EAAMW,MACnBX,GAAM3B,OAAO6L,EAAUE,GACvB/L,EAAOsE,MAAM3C,GAAQmK,EAAU,GAAG7L,OAAO4F,IACzCnE,KAAK0J,UAAUxF,OAAQ,OAAQiG,SAAUA,EAAUN,MAAOO,EAAUjG,MAAOA,GAAQ4F,IAGpFQ,QAAS,SAASC,GACjB,GAAIpG,GAAWpE,KAAKC,MAAM5B,OAE1B,OADA2B,MAAKyK,SAASrG,EAAUoG,GACjBxK,MAGRyK,SAAU,SAASrG,EAAUoG,GAC5B,GAAIvK,GAAQD,KAAKC,MAChB8J,EAAY9J,EAAMW,MAEnBtC,GAAOsE,MAAM3C,GAAQ,EAAGA,EAAMW,QAAQrC,OAAOiM,IAC7CxK,KAAK0J,UAAUxF,OAAQ,UAAWE,SAAUA,GAAW2F,IAGxDL,SAAU,SAASpI,EAAWyI,GAC7B,GAAI9J,GAAQD,KAAKC,MAChBW,EAASX,EAAMW,OACf8J,EAAS/N,GAAGsD,GAETW,KAAWmJ,GACdW,EAAOf,eAAe9K,GAAoBqF,OAAQ,MAAO1D,KAAM,SAAUuB,MAAOnB,EAAQkB,SAAUiI,IAEnGW,EAAOf,eAAe5K,EAAgBuC,KAIxCpD,EAAcW,GAAqBX,EAAca,IAIhDY,OAAQ,SAAUgL,GACjB,GAAI1J,GAAY2J,EAAOnF,EAAQ9E,EAAGjB,EACjCyF,EAASwF,EAAUjL,IACpB,IAAI,IAAayF,EAAOzD,KAAM,EAAMyD,EAASA,EAAOtF,MAE/CoB,EAAahC,EAAgBkG,EAAOrF,OAAO,CAI9C,IAFA2F,EAAS9I,EAAEsD,MAAMD,MAAMyF,OAAOkF,EAAUxI,MACxCxB,EAAI8E,EAAO7E,OACJD,MAAQiK,GACdA,GAASlL,EAAO+F,EAAO9E,GAAGjB,OAASA,EAAKG,IAAMH,EAAKG,GAAGC,OAASqF,EAAOrF,IAGlE8K,WAEG3J,GAAWxB,EAAMO,MAAMsE,MAC9BtD,EAAiBC,EAAYkE,EAAOrF,UAOzCxC,EAAOoH,IAAM,SAASmG,GACrB,QAASC,GAAIC,EAAQC,EAASzI,EAAQ0I,GACrC,GAAIC,GACHxG,EAAM1E,IACHA,MAAKmL,KACRnL,KAAKoL,cAEKL,KAAW/M,IACrB0G,EAAIyG,IAAMJ,EACVrG,EAAI2G,IAAM9I,GAAUmC,EAAI2G,QACxB3G,EAAIsG,QAAUA,GAAWtG,EAAIsG,QAC7BtG,EAAI4G,SACCL,IACAJ,EAAOU,QACVnO,EAAYsH,EAAIyG,KAAKlJ,WAAWyC,EAAI8G,IAAM,SAASnK,EAAIC,GACjD4J,IACJA,GAAW,EACXL,EAAOU,OAAO7G,EAAKrD,EAAIC,GACvB4J,EAAW/J,SAEVuD,EAAI+G,QAEJZ,EAAOa,QACVtO,EAAYsH,EAAI2G,KAAKpJ,WAAWyC,EAAIiH,IAAM,SAAStK,EAAIC,GAClD4J,IACJA,GAAW,EACXL,EAAOa,OAAOhH,EAAKrD,EAAIC,GACvB4J,EAAW/J,SAETuD,EAAIkH,UA4CX,MAtCIhO,GAAYiN,KAEfA,GACCgB,OAAQhB,IAINA,EAAOiB,UACVjB,EAASlO,EAAEoP,UAAWlB,EAAOiB,QAASjB,IAGvCA,EAAOnG,IAAM,SAASqG,EAAQC,EAASzI,EAAQ0I,GAC9C,MAAO,IAAIH,GAAIC,EAAQC,EAASzI,EAAQ0I,KAGxCH,EAAIpC,WACJ+C,OAAQZ,EAAOY,QAAU9G,EACzBiH,OAAQf,EAAOe,QAAUjH,EACzB2G,OAAQ,SAASN,GAChB,GAAItG,GAAM1E,IACV5C,GAAYsH,EAAI2G,KAAKd,QAAQM,EAAOgB,OAAOnH,EAAIyG,IAAKzG,EAAIsG,QAAUA,GAAWtG,EAAIsG,WAElFI,MAAO,WACN,GAAI1G,GAAM1E,IACN0E,GAAIyG,MACHzG,EAAI8G,KACPpO,EAAYsH,EAAIyG,KAAKxC,aAAajE,EAAI8G,IAAK9G,EAAI+G,QAE5C/G,EAAIiH,KACPvO,EAAYsH,EAAI2G,KAAK1C,aAAajE,EAAIiH,IAAKjH,EAAIkH,QAEhDlH,EAAIyG,IAAMhK,SAGZuD,IAAKoG,EACLkB,KAAMnB,IACJoB,YAAcnB,EAEVD,GAIT,MAAOlO","file":"jquery.observable.min.js","sourcesContent":["/*! JsObservable v1.0.0-beta.65 (Beta Candidate): http://jsviews.com/#jsobservable */\n/*\n * Subcomponent of JsViews\n * Data change events for data-linking\n *\n * Copyright 2015, Boris Moore\n * Released under the MIT License.\n */\n\n//jshint -W018, -W041\n\n(function(factory) {\n\t// global var is the this object, which is window when running in the usual browser environment\n\tvar global = (0, eval)('this'), // jshint ignore:line\n\t\t$ = global.jQuery;\n\n\tif (typeof define === \"function\" && define.amd) { // AMD script loader, e.g. RequireJS\n\t\tdefine([\"jquery\"], factory); // Require jQuery\n\t} else if (typeof exports === \"object\") { // CommonJS e.g. Browserify\n\t\tmodule.exports = $\n\t\t\t? factory($)\n\t\t\t: function($) { // If no global jQuery, take jQuery passed as parameter: require(\"jsobservable\")(jQuery)\n\t\t\t\treturn factory($);\n\t\t\t};\n\t} else { // Browser using plain <script> tag\n\t\tfactory(false);\n\t}\n} (\n\n// factory (for jsviews.js)\nfunction($) {\n\"use strict\";\n\n//========================== Top-level vars ==========================\n\n// global var is the this object, which is window when running in the usual browser environment\nvar global = (0, eval)('this'), // jshint ignore:line\n\tsetGlobals = $ === false; // Only set globals if script block in browser (not AMD and not CommonJS)\n\n$ = $ || global.jQuery;\n\nif (!$ || !$.fn) {\n\t// jQuery is not loaded.\n\tthrow \"JsObservable requires jQuery\"; // We require jQuery\n}\n\nvar versionNumber = \"v1.0.0-alpha\",\n\t$observe, $observable,\n\n\t$views = $.views =\n\t\t$.views ||\n\t\tsetGlobals && global.jsrender && jsrender.views || //jsrender was loaded before jquery.observable\n\t\t{ // jsrender not loaded so set up $.views and $.views.sub here, and merge back in jsrender if loaded afterwards\n\t\t\tjsviews: versionNumber,\n\t\t\tsub: {}\n\t\t},\n\t$sub = $views.sub,\n\t$isFunction = $.isFunction,\n\t$isArray = $.isArray,\n\tOBJECT = \"object\";\nif (!$.observe) {\n\n\tvar $eventSpecial = $.event.special,\n\t\tslice = [].slice,\n\t\tsplice = [].splice,\n\t\tconcat = [].concat,\n\t\t$expando = $.expando,\n\t\tPARSEINT = parseInt,\n\t\trNotWhite = /\\S+/g,\n\t\tpropertyChangeStr = $sub.propChng = $sub.propChng || \"propertyChange\",// These two settings can be overridden on settings after loading\n\t\tarrayChangeStr = $sub.arrChng = $sub.arrChng || \"arrayChange\",        // jsRender, and prior to loading jquery.observable.js and/or JsViews\n\t\tcbBindingsStore = $sub._cbBnds = $sub._cbBnds || {},\n\t\tobserveStr = propertyChangeStr + \".observe\",\n\t\tobserveObjKey = 1,\n\t\tobserveCbKey = 1,\n\t\tobserveInnerCbKey = 1,\n\t\t$hasData = $.hasData,\n\t\t$data = $.data,\n\t\tremove = {}, // flag for removeProperty\n\n\t//========================== Top-level functions ==========================\n\n\tgetCbKey = function(cb) {\n\t\treturn cb._cId = cb._cId || (\".obs\" + observeCbKey++);\n\t},\n\n\tObjectObservable = function(data) {\n\t\tthis._data = data;\n\t\treturn this;\n\t},\n\n\tArrayObservable = function(data) {\n\t\tthis._data = data;\n\t\treturn this;\n\t},\n\n\twrapArray = function(data) {\n\t\treturn $isArray(data)\n\t\t\t? [data]\n\t\t\t: data;\n\t},\n\n\tresolvePathObjects = function(paths, root) {\n\t\tpaths = $isArray(paths) ? paths : [paths];\n\n\t\tvar i, path,\n\t\t\tobject = root,\n\t\t\tnextObj = object,\n\t\t\tl = paths.length,\n\t\t\tout = [];\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tpath = paths[i];\n\t\t\tif ($isFunction(path)) {\n\t\t\t\tout = out.concat(resolvePathObjects(path.call(root, root), root));\n\t\t\t\tcontinue;\n\t\t\t} else if (\"\" + path !== path) {\n\t\t\t\troot = nextObj = path;\n\t\t\t\tif (nextObj !== object) {\n\t\t\t\t\tout.push(object = nextObj);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nextObj !== object) {\n\t\t\t\tout.push(object = nextObj);\n\t\t\t}\n\t\t\tout.push(path);\n\t\t}\n\t\treturn out;\n\t},\n\n\tremoveCbBindings = function(cbBindings, cbBindingsId) {\n\t\t// If the cbBindings collection is empty we will remove it from the cbBindingsStore\n\t\tfor (var cb in cbBindings) {\n\t\t\treturn;\n\t\t}\n\t\tcbBindingsStore[cbBindingsId] = undefined; // This binding collection is empty, so remove from store\n\t},\n\n\tonObservableChange = function(ev, eventArgs) {\n\t\tfunction isOb(val) {\n\t\t\treturn typeof val === OBJECT && (paths[0] || allowArray && $isArray(val));\n\t\t}\n\n\t\tif (!(ev.data && ev.data.off)) {\n\t\t\t// Skip if !!ev.data.off: - a handler that has already been removed (maybe was on handler collection at call time - then removed by another handler)\n\t\t\tvar allPath, filter, parentObs,\n\t\t\t\toldValue = eventArgs.oldValue,\n\t\t\t\tvalue = eventArgs.value,\n\t\t\t\tctx = ev.data,\n\t\t\t\tobserveAll = ctx.observeAll,\n\t\t\t\tallowArray = !ctx.cb.noArray,\n\t\t\t\tpaths = ctx.paths;\n\n\t\t\tif (ev.type === arrayChangeStr) {\n\t\t\t\t(ctx.cb.array || ctx.cb).call(ctx, ev, eventArgs); // If there is an arrayHandler expando on the regular handler, use it, otherwise use the regular handler for arrayChange events also - for example: $.observe(array, handler)\n\t\t\t\t// or observeAll() with an array in the graph. Note that on data-link bindings we ensure always to have an array handler - $.noop if none is specified e.g. on the data-linked tag.\n\t\t\t} else if (ctx.prop === eventArgs.path || ctx.prop === \"*\") {\n\t\t\t\tif (observeAll) {\n\t\t\t\t\tallPath = observeAll._path + \".\" + eventArgs.path;\n\t\t\t\t\tfilter = observeAll.filter;\n\t\t\t\t\tparentObs = [ev.target].concat(observeAll.parents());\n\n\t\t\t\t\tif (isOb(oldValue)) {\n\t\t\t\t\t\tobserve_apply(allowArray, observeAll.ns, [oldValue], paths, ctx.cb, true, filter, [parentObs], allPath); // unobserve\n\t\t\t\t\t}\n\t\t\t\t\tif (isOb(value)) {\n\t\t\t\t\t\tobserve_apply(allowArray, observeAll.ns, [value], paths, ctx.cb, undefined, filter, [parentObs], allPath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (isOb(oldValue)) { // oldValue is an object, so unobserve\n\t\t\t\t\t\tobserve_apply(allowArray, [oldValue], paths, ctx.cb, true); // unobserve\n\t\t\t\t\t}\n\t\t\t\t\tif (isOb(value)) { // value is an object, so observe\n\t\t\t\t\t\tobserve_apply(allowArray, [value], paths, ctx.cb);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tctx.cb(ev, eventArgs);\n\t\t\t}\n\t\t}\n\t},\n\n\tobserve_apply = function() {\n\t\t// $.observe(), but allowing you to include arrays within the arguments - which you want flattened.\n\t\tvar args = concat.apply([], arguments); // Flatten the arguments\n\t\treturn $observe.apply(args.shift(), args);\n\t},\n\n\t$observeAll = function(namespace, cb, filter, unobserve) {\n\t\tif (namespace + \"\" !== namespace) {\n\t\t\tfilter = cb;\n\t\t\tcb = namespace;\n\t\t\tnamespace = \"\";\n\t\t}\n\t\tobserveAll(namespace, this._data, cb, filter, [], \"root\", unobserve);\n\t},\n\n\t$unobserveAll = function(namespace, cb, filter) {\n\t\t$observeAll.call(this, namespace, cb, filter, true);\n\t},\n\n\tobserveAll = function(namespace, object, cb, filter, parentObs, allPath, unobserve, objMap) {\n\t\tfunction observeArrayItems(arr, unobs) {\n\t\t\tl = arr.length;\n\t\t\tnewAllPath = allPath + \"[]\";\n\t\t\twhile (l--) {\n\t\t\t\tfilterAndObserveAll(arr, l, unobs, 1);\n\t\t\t}\n\t\t}\n\n\t\tfunction filterAndObserveAll(obj, prop, unobs, nestedArray) {\n\t\t\tvar newObject, newParentObs;\n\t\t\tif (prop !== $expando) {\n\t\t\t\tif (newObject = $observable._fltr(newAllPath, obj[prop], nextParentObs, filter)) {\n\t\t\t\t\tnewParentObs = nextParentObs.slice();\n\t\t\t\t\tif (nestedArray && updatedTgt) {\n\t\t\t\t\t\tnewParentObs.unshift(updatedTgt); // For array change events need to add updated array to parentObs\n\t\t\t\t\t}\n\t\t\t\t\tobserveAll(namespace, newObject, cb, filter || (nestedArray ? undefined : 0), newParentObs, newAllPath, unobs, objMap);\n\t\t\t\t\t// If nested array, need to observe the array too - so set filter to undefined\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction wrappedCb(ev, eventArgs) {\n\t\t\t// This object is changing.\n\t\t\tallPath = ev.data.observeAll._path;\n\t\t\tupdatedTgt = ev.target;\n\t\t\tswitch (eventArgs.change) { // observeAll/unobserveAll on added or removed objects\n\t\t\t\tcase \"insert\":\n\t\t\t\t\tobserveArrayItems(eventArgs.items);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"remove\":\n\t\t\t\t\tobserveArrayItems(eventArgs.items, true); // unobserveAll on removed items\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"refresh\":\n\t\t\t\t\tobserveArrayItems(eventArgs.oldItems, true); // unobserveAll on old items\n\t\t\t\t\tobserveArrayItems(ev.target); // observeAll on new items\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"set\":\n\t\t\t\t\tnewAllPath = allPath + \".\" + eventArgs.path;\n\t\t\t\t\tfilterAndObserveAll(eventArgs, \"oldValue\", true);\n\t\t\t\t\tfilterAndObserveAll(eventArgs, \"value\");\n\t\t\t}\n\t\t\tupdatedTgt = undefined;\n\t\t\tcb.apply(this, arguments); // Observe this object (invoke the callback)\n\t\t}\n\n\t\tvar l, isObject, newAllPath, nextParentObs, updatedTgt, obId,\n\t\t\tnotRemoving = !objMap || objMap.un || !unobserve; // true unless it is an observeAll call (not unobserveAll) and we are removing a listener (not adding one)\n\n\t\tif (object && typeof object === OBJECT) {\n\t\t\tnextParentObs = [object].concat(parentObs); // The parentObs chain for the next depth of observeAll\n\t\t\tisObject = $isArray(object) ? \"\" : \"*\";\n\t\t\tif (objMap && notRemoving && $hasData(object) && objMap[obId = $data(object).obId]) {\n\t\t\t\tobjMap[obId]++;\n\t\t\t\treturn; // This object has already being observed/unobserved by this observeAll/unobserveAll call (must be a cyclic object graph) so skip, to avoid\n\t\t\t\t// stack overflow/multiple instances of listener. See https://github.com/BorisMoore/jsviews/pull/305\n\t\t\t\t// NOTE - WE DO NOT support ObserveAll on data with cyclic graphs which include DUPLICATE REFERENCES TO ARRAY PROPERTIES - such as data.children = data.descendants = []\n\t\t\t}\n\t\t\tif (!objMap) {\n\t\t\t\twindow.map = objMap = {un: unobserve}; // Map object to register observed objects for this observeAll\n\t\t\t}\n\n\t\t\tif (cb) {\n\t\t\t\t// Observe this object or array - and also listen for changes to object graph, to add or remove observers from the modified object graph\n\t\t\t\tif (isObject || filter !== 0) {\n\t\t\t\t\t// If an object, observe the object. If an array, only add arrayChange binding if has filter or if filter is undefined (!== 0) - which\n\t\t\t\t\t// is the case for top-level calls or for nested array (array item of an array - e.g. member of 2-dimensional array).\n\t\t\t\t\t// For array properties lower in the tree, with no filter, filter is set to 0 in filterAndObserveAll, so no arrayChange binding here,\n\t\t\t\t\t// since they get arrayChange binding added during regular $.observe(array ...) binding.\n\t\t\t\t\twrappedCb._cId = getCbKey(cb); // Identify wrapped callback with unwrapped callback, so unobserveAll will\n\t\t\t\t\t\t\t\t\t\t\t\t\t// remove previous observeAll wrapped callback, if inner callback was the same;\n\t\t\t\t\tif (notRemoving) {\n\t\t\t\t\t\t$observe(namespace, object, isObject, wrappedCb, unobserve, filter, nextParentObs, allPath);\n\t\t\t\t\t\tobId = $data(object).obId;\n\t\t\t\t\t\tobjMap[obId] = (objMap[obId] || 0) + 1; // Register on map of objects observed/unobserved by this observeAll/unobserveAll call\n\t\t\t\t\t\t\t//- or remove from map if we are removing this object from observeAll call. (Avoid dups, for cyclic graphs)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (--objMap[$data(object).obId]) {\n\t\t\t\t\t\t\t// Register on map of objects observed/unobserved by this observeAll/unobserveAll call\n\t\t\t\t\t\t\t//- or remove from map if we are removing this object from observeAll call. (Avoid dups, for cyclic graphs)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$observe(namespace, object, isObject, wrappedCb, unobserve, filter, nextParentObs, allPath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No callback. Just unobserve if unobserve === true.\n\t\t\t\tif (objMap) {\n\t\t\t\t\tobjMap[$data(object).obId] = 1; // Register on map of objects unobserved by this unobserveAll call. (Avoid dups, for cyclic graphs)\n\t\t\t\t}\n\t\t\t\t$observe(namespace, object, isObject, undefined, unobserve, filter, nextParentObs, allPath);\n\t\t\t}\n\n\t\t\tif (isObject) {\n\t\t\t\t// Continue stepping through object graph, observing object and arrays\n\t\t\t\t// To override filtering, pass in filter function, or replace $.observable._fltr\n\t\t\t\tfor (l in object) {\n\t\t\t\t\tnewAllPath = allPath + \".\" + l;\n\t\t\t\t\tfilterAndObserveAll(object, l, unobserve);\n\t\t\t\t}\n\t\t\t} else { // Observe items in Array\n\t\t\t\tobserveArrayItems(object, unobserve);\n\t\t\t}\n\t\t}\n\t},\n\n\tshallowFilter = function(allPath /*, object, parentObs*/) {\n\t\treturn allPath.indexOf(\".\") < 0 && allPath.indexOf(\"[\") < 0;\n\t},\n\n\t$unobserve = function() {\n\t\t[].push.call(arguments, true); // Add true as additional final argument\n\t\treturn $observe.apply(this, arguments);\n\t};\n\n\t$observe = function() {\n\t\t// $.observe([namespace, ]root, [1 or more objects, path or path Array params...], callback[, contextCallback][, unobserve])\n\n\t\tfunction innerObserve() {\n\n\t\t\tfunction observeOnOff(namespace, pathStr, isArrayBinding, off) {\n\t\t\t\tvar j, evData,\n\t\t\t\t\tobIdExpando = $hasData(object),\n\t\t\t\t\tboundObOrArr = wrapArray(object),\n\t\t\t\t\tprntObs = parentObs,\n\t\t\t\t\tallPth = allPath;\n\n\t\t\t\tnamespace = initialNs ? namespace + \".\" + initialNs : namespace;\n\n\t\t\t\tif (unobserve || off) {\n\t\t\t\t\tif (obIdExpando) {\n\t\t\t\t\t\t$(boundObOrArr).off(namespace, onObservableChange);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (events = obIdExpando && $._data(object)) {\n\t\t\t\t\t\tevents = events && events.events;\n\t\t\t\t\t\tevents = events && events[isArrayBinding ? arrayChangeStr : propertyChangeStr];\n\t\t\t\t\t\tel = events && events.length;\n\n\t\t\t\t\t\twhile (el--) {\n\t\t\t\t\t\t\tif ((data = events[el].data) && data.cb && data.cb._cId === callback._cId && data.ns === initialNs) {\n\t\t\t\t\t\t\t\tif (isArrayBinding) {\n\t\t\t\t\t\t\t\t\t// Duplicate exists, so skip. (This can happen e.g. with {^{for people ~foo=people}})\n\t\t\t\t\t\t\t\t\t// or for cases with cyclic objects - e.g. obj.children = obj.descendants = []\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else if (pathStr === \"*\" && data.prop !== pathStr) {\n\t\t\t\t\t\t\t\t\t$(object).off(namespace, onObservableChange);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tevData = isArrayBinding ? {}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\tfullPath: path,\n\t\t\t\t\t\t\tpaths: pathStr ? [pathStr] : [],\n\t\t\t\t\t\t\tprop: prop\n\t\t\t\t\t\t};\n\t\t\t\t\tevData.ns = initialNs;\n\t\t\t\t\tevData.cb = callback;\n\n\t\t\t\t\tif (allPath) {\n\t\t\t\t\t\t// This is an observeAll call\n\t\t\t\t\t\tevData.observeAll = {\n\t\t\t\t\t\t\t_path: allPth,\n\t\t\t\t\t\t\tpath: function() { // Step through path and parentObs parent chain, replacing '[]' by '[n]' based on current index of objects in parent arrays.\n\t\t\t\t\t\t\t\tj = prntObs.length;\n\t\t\t\t\t\t\t\treturn allPth.replace(/[[.]/g, function(all) {\n\t\t\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t\t\t\treturn all === \"[\"\n\t\t\t\t\t\t\t\t\t\t? \"[\" + $.inArray(prntObs[j - 1], prntObs[j])\n\t\t\t\t\t\t\t\t\t\t: \".\";\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tparents: function() {\n\t\t\t\t\t\t\t\treturn prntObs; // The chain of parents between the modified object and the root object used in the observeAll() call\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfilter: filter,\n\t\t\t\t\t\t\tns: initialNs\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\t$(boundObOrArr).on(namespace, null, evData, onObservableChange);\n\t\t\t\t\tif (cbBindings) {\n\t\t\t\t\t\t// Add object to cbBindings, and add the counter to the jQuery data on the object\n\t\t\t\t\t\t(cbBindingsStore[callback._cId] = cbBindings) // In some scenarios cbBindings was empty and removed\n\t\t\t\t\t\t\t//from store - so defensively add back to store, to ensure correct disposal e.g. when views are removed\n\t\t\t\t\t\t\t[$data(object).obId || $data(object, \"obId\", observeObjKey++)] = object;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction getInnerCb(exprOb) {\n\t\t\t\t// Returns the innerCb used for updating a computed in a compiled expression (setting the new instance as exprOb.ob, unobserving the previous object,\n\t\t\t\t// and observing the new one), then calling the outerCB - i.e. the handler for the whole compiled expression.\n\t\t\t\t// Initialized exprOb.ob to the current object.\n\t\t\t\t// Uses the contextCb callback to execute the compiled exprOb template in the context of the view/data etc. to get the returned value, typically an object or array.\n\t\t\t\t// If it is an array, registers array binding\n\t\t\t\tvar origRt = root;\n\t\t\t\t// Note:  For https://github.com/BorisMoore/jsviews/issues/292ctxCb will need var ctxCb = contextCb || function(exprOb, origRt) {return exprOb._jsv(origRt);};\n\n\t\t\t\texprOb.ob = contextCb(exprOb, origRt); // Initialize object\n\n\t\t\t\treturn exprOb.cb = function(ev, eventArgs) {\n\t\t\t\t\tvar obj = exprOb.ob, // The old object\n\t\t\t\t\t\tsub = exprOb.sb,\n\t\t\t\t\t\tnewObj = contextCb(exprOb, origRt);\n\n\t\t\t\t\tif (newObj !== obj) {\n\t\t\t\t\t\tif (typeof obj === OBJECT) {\n\t\t\t\t\t\t\tbindArray(obj, true);\n\t\t\t\t\t\t\tif (sub || allowArray && $isArray(obj)) {\n\t\t\t\t\t\t\t\tinnerObserve([obj], sub, callback, contextCb, true); // unobserve on the old object\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\texprOb.ob = newObj;\n\t\t\t\t\t\t// Put the updated object instance onto the exprOb in the paths array, so subsequent string paths are relative to this object\n\t\t\t\t\t\tif (typeof newObj === OBJECT) {\n\t\t\t\t\t\t\tbindArray(newObj);\n\t\t\t\t\t\t\tif (sub || allowArray && $isArray(newObj)) {\n\t\t\t\t\t\t\t\t// Register array binding\n\t\t\t\t\t\t\t\tinnerObserve([newObj], sub, callback, contextCb);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Call the outerCb - to execute the compiled expression that this computed is part of\n\t\t\t\t\tcallback(ev, eventArgs);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfunction bindArray(arr, unbind, isArray, relPath) {\n\t\t\t\tif (allowArray) {\n\t\t\t\t\t// This is a call to observe that does not come from observeAndBind (tag binding), so we allow arrayChange binding\n\t\t\t\t\tvar prevObj = object,\n\t\t\t\t\t\tprevAllPath = allPath;\n\n\t\t\t\t\tobject = arr;\n\t\t\t\t\tif (relPath) {\n\t\t\t\t\t\tobject = arr[relPath];\n\t\t\t\t\t\tallPath += \".\" + relPath;\n\t\t\t\t\t}\n\t\t\t\t\tif (filter && object) {\n\t\t\t\t\t\tobject = $observable._fltr(allPath, object, relPath ? [arr].concat(parentObs) : parentObs, filter);\n\t\t\t\t\t}\n\t\t\t\t\tif (object && (isArray || $isArray(object))) {\n\t\t\t\t\t\tobserveOnOff(arrayChangeStr + \".observe\" + (callback ? (cbId = getCbKey(callback)) : \"\"), undefined, true, unbind);\n\t\t\t\t\t}\n\t\t\t\t\tobject = prevObj;\n\t\t\t\t\tallPath = prevAllPath;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar i, p, skip, parts, prop, path, dep, unobserve, callback, cbId, el, data, events, contextCb, items, cbBindings, depth, innerCb, parentObs,\n\t\t\t\tallPath, filter, initNsArr, initNsArrLen,\n\t\t\t\tns = observeStr,\n\t\t\t\tpaths = this != 1 // Using != for IE<10 bug- see https://github.com/BorisMoore/jsviews/issues/237\n\t\t\t\t\t? concat.apply([], arguments) // Flatten the arguments - this is a 'recursive call' with params using the 'wrapped array'\n\t\t\t\t\t\t\t\t\t\t\t\t\t// style - such as innerObserve([object], path.path, [origRoot], path.prm, innerCb, ...);\n\t\t\t\t\t: slice.call(arguments),   // Don't flatten - this is the first 'top-level call, to innerObserve.apply(1, paths)\n\t\t\t\tlastArg = paths.pop() || false,\n\t\t\t\troot = paths.shift(),\n\t\t\t\tobject = root,\n\t\t\t\tl = paths.length;\n\n\t\t\tif (lastArg + \"\" === lastArg) { // If last arg is a string then this observe call is part of an observeAll call,\n\t\t\t\tallPath = lastArg;          // and the last three args are the parentObs array, the filter, and the allPath string.\n\t\t\t\tparentObs = paths.pop();\n\t\t\t\tfilter = paths.pop();\n\t\t\t\tlastArg = !!paths.pop(); // unobserve\n\t\t\t\tl -= 3;\n\t\t\t}\n\t\t\tif (lastArg === !!lastArg) {\n\t\t\t\tunobserve = lastArg;\n\t\t\t\tlastArg = paths[l-1];\n\t\t\t\tlastArg = l && lastArg + \"\" !== lastArg ? (l--, paths.pop()) : undefined;\n\t\t\t}\n\t\t\tcallback = lastArg;\n\t\t\tif (l && $isFunction(paths[l - 1])) {\n\t\t\t\tcontextCb = callback;\n\t\t\t\tcallback = paths.pop();\n\t\t\t\tl--;\n\t\t\t}\n\n\t\t\t// Use a unique namespace (e.g. obs7) associated with each observe() callback to allow unobserve to remove handlers\n\t\t\tns += unobserve\n\t\t\t\t? (callback ? callback._cId + (callback._inId || \"\"): \"\")\n\t\t\t\t: (cbId = getCbKey(callback)) + (callback._inId || \"\");\n\t\t\tif (!unobserve) {\n\t\t\t\tcbBindings = cbBindingsStore[cbId] = cbBindingsStore[cbId] || {};\n\t\t\t}\n\n\t\t\tinitNsArr = initialNs && initialNs.match(rNotWhite) || [\"\"];\n\t\t\tinitNsArrLen = initNsArr.length;\n\n\t\t\twhile (initNsArrLen--) {\n\t\t\t\tinitialNs = initNsArr[initNsArrLen];\n\n\t\t\t\tif ($isArray(root)) {\n\t\t\t\t\tbindArray(root, unobserve, true);\n\t\t\t\t} else {\n\t\t\t\t\t// remove onObservableChange handlers that wrap that callback\n\t\t\t\t\tif (unobserve && l === 0 && root) {\n\t\t\t\t\t\tobserveOnOff(ns, \"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdepth = 0;\n\t\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\t\tpath = paths[i];\n\t\t\t\t\tif (path === \"\" || path === undefined) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tobject = root;\n\t\t\t\t\tif (\"\" + path === path) {\n\t\t\t\t\t\t// Consider support for computed paths: https://github.com/BorisMoore/jsviews/issues/292\n\t\t\t\t\t\t//if (/[\\(\\[\\+]/.test(path)) {\n\t\t\t\t\t\t//\tvar b={links:{}}, t = $sub.tmplFn(\"{:\"+path+\"}\", b, true), items = t.paths[0];\n\t\t\t\t\t\t//\tl += items.length - 1;\n\t\t\t\t\t\t//\tsplice.apply(paths, [i--, 1].concat(items));\n\t\t\t\t\t\t//\tcontinue;\n\t\t\t\t\t\t//}\n\t\t\t\t\t\tparts = path.split(\"^\");\n\t\t\t\t\t\tif (parts[1]) {\n\t\t\t\t\t\t\t// We bind the leaf, plus additional nodes based on depth.\n\t\t\t\t\t\t\t// \"a.b.c^d.e\" is depth 2, so listens to changes of e, plus changes of d and of c\n\t\t\t\t\t\t\tdepth = parts[0].split(\".\").length;\n\t\t\t\t\t\t\tpath = parts.join(\".\");\n\t\t\t\t\t\t\tdepth = path.split(\".\").length - depth;\n\t\t\t\t\t\t\t// if more than one ^ in the path, the first one determines depth\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (contextCb && (items = contextCb(path, root))) {\n\t\t\t\t\t\t\t// If contextCb returns an array of objects and paths, we will insert them\n\t\t\t\t\t\t\t// into the sequence, replacing the current item (path)\n\t\t\t\t\t\t\tl += items.length - 1;\n\t\t\t\t\t\t\tsplice.apply(paths, [i--, 1].concat(items));\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparts = path.split(\".\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!$isFunction(path)) {\n\t\t\t\t\t\t\tif (path && path._jsv) {\n\t\t\t\t\t\t\t\t// This is a compiled function for binding to an object returned by a helper/data function.\n\t\t\t\t\t\t\t\t// Set current object on exprOb.ob, and get innerCb for updating the object\n\t\t\t\t\t\t\t\tinnerCb = unobserve ? path.cb : getInnerCb(path);\n\t\t\t\t\t\t\t\tinnerCb.noArray = !allowArray;\n\t\t\t\t\t\t\t\tinnerCb._cId = callback._cId;\n\t\t\t\t\t\t\t\t// Set the same cbBindingsStore key as for callback, so when callback is disposed, disposal of innerCb happens too.\n\t\t\t\t\t\t\t\tinnerCb._inId = innerCb._inId || \".obIn\" + observeInnerCbKey++;\n\t\t\t\t\t\t\t\tif (path.bnd || path.prm && path.prm.length || !path.sb) {\n\t\t\t\t\t\t\t\t\t// If the exprOb is bound e.g. foo()^sub.path, or has parameters e.g. foo(bar) or is a leaf object (so no sub path) e.g. foo()\n\t\t\t\t\t\t\t\t\t// then observe changes on the object, or its parameters and sub-path\n\t\t\t\t\t\t\t\t\tinnerObserve([object], path.path, [origRoot], path.prm, innerCb, contextCb, unobserve);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (path.sb) { // subPath\n\t\t\t\t\t\t\t\t\tinnerObserve([path.ob], path.sb, callback, contextCb, unobserve);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpath = origRoot;\n\t\t\t\t\t\t\t\tobject = undefined;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tobject = path; // For top-level calls, objects in the paths array become the origRoot for subsequent paths.\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparts = [root = path];\n\t\t\t\t\t}\n\t\t\t\t\twhile (object && (prop = parts.shift()) !== undefined) {\n\t\t\t\t\t\tif (typeof object === OBJECT) {\n\t\t\t\t\t\t\tif (\"\" + prop === prop) {\n\t\t\t\t\t\t\t\tif (prop === \"\") {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ((parts.length < depth + 1) && !object.nodeType) {\n\t\t\t\t\t\t\t\t\t// Add observer for each token in path starting at depth, and on to the leaf\n\t\t\t\t\t\t\t\t\tif (!unobserve && (events = $hasData(object) && $._data(object))) {\n\t\t\t\t\t\t\t\t\t\tevents = events.events;\n\t\t\t\t\t\t\t\t\t\tevents = events && events[propertyChangeStr];\n\t\t\t\t\t\t\t\t\t\tel = events && events.length;\n\t\t\t\t\t\t\t\t\t\tskip = 0;\n\t\t\t\t\t\t\t\t\t\twhile (el--) { // Skip duplicates\n\t\t\t\t\t\t\t\t\t\t\tdata = events[el].data;\n\t\t\t\t\t\t\t\t\t\t\tif (data && data.cb === callback && data.ns === initialNs) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (data.prop === prop || data.prop === \"*\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (p = parts.join(\".\")) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.paths.push(p); // We will skip this binding, but if it is not a leaf binding,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// need to keep bindings for rest of path, ready for if the object gets swapped.\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tskip++;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (skip) {\n\t\t\t\t\t\t\t\t\t\t\t// Duplicate binding(s) found, so move on\n\t\t\t\t\t\t\t\t\t\t\tobject = object[prop];\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (prop === \"*\") {\n\t\t\t\t\t\t\t\t\t\tif (!unobserve && events && events.length) {\n\t\t\t\t\t\t\t\t\t\t\t// Remove existing bindings, since they will be duplicates with \"*\"\n\t\t\t\t\t\t\t\t\t\t\tobserveOnOff(ns, \"\", false, true);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tobserveOnOff(ns, \"\"); // observe the object for any property change\n\t\t\t\t\t\t\t\t\t\tfor (p in object) {\n\t\t\t\t\t\t\t\t\t\t\t// observing \"*\": So (in addition to listening to prop change, above) listen to arraychange on props of type array\n\t\t\t\t\t\t\t\t\t\t\tif (p !== $expando) {\n\t\t\t\t\t\t\t\t\t\t\t\tbindArray(object, unobserve, undefined, p);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t} else if (prop) {\n\t\t\t\t\t\t\t\t\t\tobserveOnOff(ns + \".\" + prop, parts.join(\"^\")); // By using \"^\" rather than \".\" we ensure that deep binding will be used on newly inserted object graphs\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (allPath) {\n\t\t\t\t\t\t\t\t\tallPath += \".\" + prop;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tprop = object[prop];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ($isFunction(prop)) {\n\t\t\t\t\t\t\t\tif (dep = prop.depends) {\n\t\t\t\t\t\t\t\t\t// This is a computed observable. We will observe any declared dependencies\n\t\t\t\t\t\t\t\t\tinnerObserve([object], resolvePathObjects(dep, object), callback, contextCb, unobserve);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tobject = prop;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbindArray(object, unobserve);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cbId) {\n\t\t\t\tremoveCbBindings(cbBindings, cbId);\n\t\t\t}\n\n\t\t\t// Return the cbBindings to the top-level caller, along with the cbId\n\t\t\treturn { cbId: cbId, bnd: cbBindings };\n\t\t}\n\n\t\tvar initialNs,\n\t\t\tallowArray = this != false, // If this === false, this is a call from observeAndBind - doing binding of datalink expressions. We don't bind\n\t\t\t// arrayChange events in this scenario. Instead, {^{for}} and similar do specific arrayChange binding to the tagCtx.args[0] value, in onAfterLink.\n\t\t\t// Note deliberately using this != false, rather than this !== false because of IE<10 bug- see https://github.com/BorisMoore/jsviews/issues/237\n\t\t\tpaths = slice.call(arguments),\n\t\t\torigRoot = paths[0];\n\n\t\tif (origRoot + \"\" === origRoot && allowArray) {\n\t\t\tinitialNs = origRoot; // The first arg is a namespace, since it is  a string, and this call is not from observeAndBind\n\t\t\tpaths.shift();\n\t\t\torigRoot = paths[0];\n\t\t}\n\n\t\treturn innerObserve.apply(1, paths);\n\t};\n\n\t$observable = function(data) {\n\t\treturn $isArray(data)\n\t\t\t? new ArrayObservable(data)\n\t\t\t: new ObjectObservable(data);\n\t};\n\n\t//========================== Initialize ==========================\n\n\t$sub.getDeps = function() {\n\t\tvar args = arguments;\n\t\treturn function() {\n\t\t\tvar arg, dep,\n\t\t\t\tdeps = [],\n\t\t\t\tl = args.length;\n\t\t\twhile (l--) {\n\t\t\t\targ = args[l--];\n\t\t\t\tdep = args[l];\n\t\t\t\tif (dep) {\n\t\t\t\t\tdeps = deps.concat($isFunction(dep) ? dep(arg, arg) : dep);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn deps;\n\t\t};\n\t};\n\n\t$.observable = $observable;\n\t$observable._fltr = function(allPath, object, parentObs, filter) {\n\t\tif (filter && $isFunction(filter)\n\t\t\t? filter(allPath, object, parentObs)\n\t\t\t: true // TODO Consider supporting filter being a string or strings to do RegEx filtering based on key and/or allPath\n\t\t) {\n\t\t\tobject = $isFunction(object)\n\t\t\t\t? object.set && object.call(parentObs[0]) // It is a getter/setter\n\t\t\t\t: object;\n\t\t\treturn typeof object === OBJECT && object;\n\t\t}\n\t};\n\n\t$observable.Object = ObjectObservable;\n\t$observable.Array = ArrayObservable;\n\t$.observe = $observable.observe = $observe;\n\t$.unobserve = $observable.unobserve = $unobserve;\n\t$observable._apply = observe_apply;\n\n\tObjectObservable.prototype = {\n\t\t_data: null,\n\n\t\tobserveAll: $observeAll,\n\t\tunobserveAll: $unobserveAll,\n\n\t\tdata: function() {\n\t\t\treturn this._data;\n\t\t},\n\n\t\tsetProperty: function(path, value, nonStrict) {\n\t\t\tvar key, pair, parts,\n\t\t\t\tself = this,\n\t\t\t\tobject = self._data;\n\n\t\t\tpath = path || \"\";\n\t\t\tif (object) {\n\t\t\t\tif ($isArray(path)) {\n\t\t\t\t\t// This is the array format generated by serializeArray. However, this has the problem that it coerces types to string,\n\t\t\t\t\t// and does not provide simple support of convertTo and convertFrom functions.\n\t\t\t\t\tkey = path.length;\n\t\t\t\t\twhile (key--) {\n\t\t\t\t\t\tpair = path[key];\n\t\t\t\t\t\tself.setProperty(pair.name, pair.value, nonStrict === undefined || nonStrict); //If nonStrict not specified, default to true;\n\t\t\t\t\t}\n\t\t\t\t} else if (\"\" + path !== path) {\n\t\t\t\t\t// Object representation where property name is path and property value is value.\n\t\t\t\t\tfor (key in path) {\n\t\t\t\t\t\tself.setProperty(key, path[key], nonStrict);\n\t\t\t\t\t}\n\t\t\t\t} else if (path !== $expando) {\n\t\t\t\t\t// Simple single property case.\n\t\t\t\t\tparts = path.split(\".\");\n\t\t\t\t\twhile (object && parts.length > 1) {\n\t\t\t\t\t\tobject = object[parts.shift()];\n\t\t\t\t\t}\n\t\t\t\t\tif (object) {\n\t\t\t\t\t\tself._setProperty(object, parts[0], value, nonStrict);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\n\t\tremoveProperty: function(path) {\n\t\t\tthis.setProperty(path, remove);\n\t\t\treturn this;\n\t\t},\n\n\t\t_setProperty: function(leaf, path, value, nonStrict) {\n\t\t\tvar setter, getter, removeProp,\n\t\t\t\tproperty = path ? leaf[path] : leaf;\n\n\t\t\tif ($isFunction(property)) {\n\t\t\t\tif (property.set) {\n\t\t\t\t\t// Case of property setter/getter - with convention that property is getter and property.set is setter\n\t\t\t\t\tgetter = property;\n\t\t\t\t\tsetter = property.set === true ? property : property.set;\n\t\t\t\t\tproperty = property.call(leaf); // get - only treated as getter if also a setter. Otherwise it is simply a property of type function. See unit tests 'Can observe properties of type function'.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (property !== value || nonStrict && property != value) { // Optional non-strict equality, since serializeArray, and form-based editors can map numbers to strings, etc.\n\t\t\t\t// Date objects don't support != comparison. Treat as special case.\n\t\t\t\tif (!(property instanceof Date) || property > value || property < value) {\n\t\t\t\t\tif (setter) {\n\t\t\t\t\t\tsetter.call(leaf, value);\t//set\n\t\t\t\t\t\tvalue = getter.call(leaf);\t//get updated value\n\t\t\t\t\t} else if (removeProp = value === remove) {\n\t\t\t\t\t\tdelete leaf[path];\n\t\t\t\t\t\tvalue = undefined;\n\t\t\t\t\t} else if (path) {\n\t\t\t\t\t\tleaf[path] = value;\n\t\t\t\t\t}\n\t\t\t\t\tthis._trigger(leaf, {change: \"set\", path: path, value: value, oldValue: property, remove: removeProp});\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_trigger: function(target, eventArgs) {\n\t\t\t$(target).triggerHandler(propertyChangeStr, eventArgs);\n\t\t}\n\t};\n\n\tArrayObservable.prototype = {\n\t\t_data: null,\n\n\t\tobserveAll: $observeAll,\n\t\tunobserveAll: $unobserveAll,\n\n\t\tdata: function() {\n\t\t\treturn this._data;\n\t\t},\n\n\t\tinsert: function(index, data) {\n\t\t\tvar _data = this._data;\n\t\t\tif (arguments.length === 1) {\n\t\t\t\tdata = index;\n\t\t\t\tindex = _data.length;\n\t\t\t}\n\t\t\tindex = PARSEINT(index);\n\t\t\tif (index > -1 && index <= _data.length) {\n\t\t\t\tdata = $isArray(data) ? data : [data];\n\t\t\t\t// data can be a single item (including a null/undefined value) or an array of items.\n\t\t\t\t// Note the provided items are inserted without being cloned, as direct references to the provided objects\n\n\t\t\t\tif (data.length) {\n\t\t\t\t\tthis._insert(index, data);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t_insert: function(index, data) {\n\t\t\tvar _data = this._data,\n\t\t\t\toldLength = _data.length;\n\t\t\tsplice.apply(_data, [index, 0].concat(data));\n\t\t\tthis._trigger({change: \"insert\", index: index, items: data}, oldLength);\n\t\t},\n\n\t\tremove: function(index, numToRemove) {\n\t\t\tvar items,\n\t\t\t\t_data = this._data;\n\n\t\t\tif (index === undefined) {\n\t\t\t\tindex = _data.length - 1;\n\t\t\t}\n\n\t\t\tindex = PARSEINT(index);\n\t\t\tnumToRemove = numToRemove ? PARSEINT(numToRemove) : numToRemove === 0 ? 0 : 1; // if null or undefined: remove 1\n\t\t\tif (numToRemove > -1 && index > -1) {\n\t\t\t\titems = _data.slice(index, index + numToRemove);\n\t\t\t\tnumToRemove = items.length;\n\t\t\t\tif (numToRemove) {\n\t\t\t\t\tthis._remove(index, numToRemove, items);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t_remove: function(index, numToRemove, items) {\n\t\t\tvar _data = this._data,\n\t\t\t\toldLength = _data.length;\n\n\t\t\t_data.splice(index, numToRemove);\n\t\t\tthis._trigger({change: \"remove\", index: index, items: items}, oldLength);\n\t\t},\n\n\t\tmove: function(oldIndex, newIndex, numToMove) {\n\t\t\tnumToMove = numToMove ? PARSEINT(numToMove) : numToMove === 0 ? 0 : 1; // if null or undefined: move 1\n\t\t\toldIndex = PARSEINT(oldIndex);\n\t\t\tnewIndex = PARSEINT(newIndex);\n\n\t\t\tif (numToMove > 0 && oldIndex > -1 && newIndex > -1 && oldIndex !== newIndex) {\n\t\t\t\tvar items = this._data.slice(oldIndex, oldIndex + numToMove);\n\t\t\t\tnumToMove = items.length;\n\t\t\t\tif (numToMove) {\n\t\t\t\t\tthis._move(oldIndex, newIndex, numToMove, items);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t_move: function(oldIndex, newIndex, numToMove, items) {\n\t\t\tvar _data = this._data,\n\t\t\t\toldLength = _data.length;\n\t\t\t_data.splice(oldIndex, numToMove);\n\t\t\tsplice.apply(_data, [newIndex, 0].concat(items));\n\t\t\tthis._trigger({change: \"move\", oldIndex: oldIndex, index: newIndex, items: items}, oldLength);\n\t\t},\n\n\t\trefresh: function(newItems) {\n\t\t\tvar oldItems = this._data.slice();\n\t\t\tthis._refresh(oldItems, newItems);\n\t\t\treturn this;\n\t\t},\n\n\t\t_refresh: function(oldItems, newItems) {\n\t\t\tvar _data = this._data,\n\t\t\t\toldLength = _data.length;\n\n\t\t\tsplice.apply(_data, [0, _data.length].concat(newItems));\n\t\t\tthis._trigger({change: \"refresh\", oldItems: oldItems}, oldLength);\n\t\t},\n\n\t\t_trigger: function(eventArgs, oldLength) {\n\t\t\tvar _data = this._data,\n\t\t\t\tlength = _data.length,\n\t\t\t\t$_data = $([_data]);\n\n\t\t\tif (length !== oldLength) {\n\t\t\t\t$_data.triggerHandler(propertyChangeStr, {change: \"set\", path: \"length\", value: length, oldValue: oldLength});\n\t\t\t}\n\t\t\t$_data.triggerHandler(arrayChangeStr, eventArgs);\n\t\t}\n\t};\n\n\t$eventSpecial[propertyChangeStr] = $eventSpecial[arrayChangeStr] = {\n\t\t// Register a jQuery special 'remove' event, to access the data associated with handlers being removed by jQuery.off().\n\t\t// We get data.cb._cId from the event handleObj and get the corresponding cbBindings hash from the cbBindingsStore,\n\t\t// then remove this object from that bindings hash - if the object does not have any other handlers associated with the same callback.\n\t\tremove: function (handleObj) {\n\t\t\tvar cbBindings, found, events, l, data,\n\t\t\t\tevData = handleObj.data;\n\t\t\tif ((evData) && (evData.off = true, evData = evData.cb)) { //Set off = true as marker for disposed event\n\t\t\t\t// Get the cb._cId from handleObj.data.cb._cId\n\t\t\t\tif (cbBindings = cbBindingsStore[evData._cId]) {\n\t\t\t\t\t// There were bindings for this callback. If this was the last one, we'll remove it.\n\t\t\t\t\tevents = $._data(this).events[handleObj.type];\n\t\t\t\t\tl = events.length;\n\t\t\t\t\twhile (l-- && !found) {\n\t\t\t\t\t\tfound = (data = events[l].data) && data.cb && data.cb._cId === evData._cId;\n\t\t\t\t\t\t// Found another one with same callback (though may be a different innerCallback)\n\t\t\t\t\t}\n\t\t\t\t\tif (!found) {\n\t\t\t\t\t\t// This was the last handler for this callback and object, so remove the binding entry\n\t\t\t\t\t\tdelete cbBindings[$data(this).obId];\n\t\t\t\t\t\tremoveCbBindings(cbBindings, evData._cId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t$views.map = function(mapDef) {\n\t\tfunction Map(source, options, target, unbound) {\n\t\t\tvar changing,\n\t\t\t\tmap = this;\n\t\t\tif (this.src) {\n\t\t\t\tthis.unmap(); // We are re-mapping a new source\n\t\t\t}\n\t\t\tif (typeof source === OBJECT) {\n\t\t\t\tmap.src = source;\n\t\t\t\tmap.tgt = target || map.tgt || [];\n\t\t\t\tmap.options = options || map.options;\n\t\t\t\tmap.update();\n\t\t\t\tif (!unbound) {\n\t\t\t\t\tif (mapDef.obsSrc) {\n\t\t\t\t\t\t$observable(map.src).observeAll(map.obs = function(ev, eventArgs) {\n\t\t\t\t\t\t\tif (!changing) {\n\t\t\t\t\t\t\t\tchanging = true;\n\t\t\t\t\t\t\t\tmapDef.obsSrc(map, ev, eventArgs);\n\t\t\t\t\t\t\t\tchanging = undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, map.srcFlt);\n\t\t\t\t\t}\n\t\t\t\t\tif (mapDef.obsTgt ) {\n\t\t\t\t\t\t$observable(map.tgt).observeAll(map.obt = function(ev, eventArgs) {\n\t\t\t\t\t\tif (!changing) {\n\t\t\t\t\t\t\tchanging = true;\n\t\t\t\t\t\t\tmapDef.obsTgt(map, ev, eventArgs);\n\t\t\t\t\t\t\tchanging = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}, map.tgtFlt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ($isFunction(mapDef)) {\n\t\t\t// Simple map declared as function\n\t\t\tmapDef = {\n\t\t\t\tgetTgt: mapDef\n\t\t\t};\n\t\t}\n\n\t\tif (mapDef.baseMap) {\n\t\t\tmapDef = $.extend({}, mapDef.baseMap, mapDef);\n\t\t}\n\n\t\tmapDef.map = function(source, options, target, unbound) {\n\t\t\treturn new Map(source, options, target, unbound);\n\t\t};\n\n\t\t(Map.prototype = {\n\t\t\tsrcFlt: mapDef.srcFlt || shallowFilter, // default to shallowFilter\n\t\t\ttgtFlt: mapDef.tgtFlt || shallowFilter,\n\t\t\tupdate: function(options) {\n\t\t\t\tvar map = this;\n\t\t\t\t$observable(map.tgt).refresh(mapDef.getTgt(map.src, map.options = options || map.options));\n\t\t\t},\n\t\t\tunmap: function() {\n\t\t\t\tvar map = this;\n\t\t\t\tif (map.src) {\n\t\t\t\t\tif (map.obs) {\n\t\t\t\t\t\t$observable(map.src).unobserveAll(map.obs, map.srcFlt);\n\t\t\t\t\t}\n\t\t\t\t\tif (map.obt) {\n\t\t\t\t\t\t$observable(map.tgt).unobserveAll(map.obt, map.tgtFlt);\n\t\t\t\t\t}\n\t\t\t\t\tmap.src = undefined;\n\t\t\t\t}\n\t\t\t},\n\t\t\tmap: Map,\n\t\t\t_def: mapDef\n\t\t}).constructor = Map;\n\n\t\treturn mapDef;\n\t};\n}\n\nreturn $;\n}));\n"],"sourceRoot":"/source/"}